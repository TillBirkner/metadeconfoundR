#' ImportLongPrior
#'
#' ImportLongPrior imports prior knowledge of associations between individual
#' features and metadata in form of a long-format dataframe.
#'
#' @param longPrior long-format dataframe as generated by
#' Metadeconfound(returnLong = TRUE). Must contain at least one column
#' containing feature names and one column containing associated metadata names,
#' called "feature" and "metadata", respectively. Only associations between
#' features and metadata present in featureMat and metaMat will be returned.
#' Additionally, "Qs" and "status" (as produced by
#' \link[metadeconfoundR]{MetaDeconfound})columns can be supplied and will
#' be parsed as well.
#' If only "feature" and "metadata"columns are supplied, all listed
#' associations are assumed to be significant.
#' If "status" is supplied, only non-"NS" labeled associations will be kept.
#' @param featureMat omics features to be analyzed by \link[metadeconfoundR]{MetaDeconfound}
#' @param metaMat metadata to be analyzed by \link[metadeconfoundR]{MetaDeconfound}
#' @return wide-format dataframe that can be used as minQValues parameter in
#' \link[metadeconfoundR]{MetaDeconfound}
#' @details This function is meant to facilitate incorporation of prior
#' knowledge about associations between measured omics features and available
#' metadata both from earlier metadeconfoundR runs by supplying the long-format
#' Metadeconfound() output directly or by supplying a simple list of known
#' associations from other studies.
#' @examples
#'data(reduced_feature)
#'data(metaMatMetformin)
#'\donttest{
#'example_output <- MetaDeconfound(featureMat = reduced_feature,
#'                                   metaMat = metaMatMetformin,
#'                                   returnLong = TRUE)
#'
#' minQValues <- ImportLongPrior(longPrior = example_output,
#'                                 featureMat = reduced_feature,
#'                                 metaMat = metaMatMetformin,
#'                                   )
#'}
#'
#'example_output <- MetaDeconfound(featureMat = reduced_feature,
#'                                   metaMat = metaMatMetformin,
#'                                   minQValues = minQValues)


#' @import futile.logger
#' @importFrom reshape2 dcast
#' @export


ImportLongPrior <- function(longPrior,
                            featureMat,
                            metaMat) {

  # assign artificial Qs for input only containing feature, metadata columns
    # without addtional info
  if (ncol(longPrior) == 2) {
    longPrior$Qs <- -1
    longPrior <-  longPrior[, c("feature", "metadata", "Qs")]
  }
  # if status column exists: filter out NS and NA and add artificial Qs if not
    # present
  else if(!is.null(longPrior$status)) {
    longPrior <- subset(x = longPrior, (status != "NS") & !is.na(status))
    if (is.null(longPrior$Qs)) {
      longPrior$Qs <- -1
    }
    longPrior <-  longPrior[, c("feature", "metadata", "Qs")]
  }
  # just reduce longPrios to needed columns
  else if(!is.null(longPrior$Qs)){
    longPrior <-  longPrior[, c("feature", "metadata", "Qs")]
  }
  #reshape data into wide format to fit minQValues data format
  widePrior <- reshape2::dcast(data = longPrior,
                               formula = feature ~ metadata,
                               value.var = "Qs")
  rownames(widePrior) <- widePrior$feature
  widePrior$feature <- NULL
  # only include features and metadata present in current yet-to-analyse dataset
  widePrior <- widePrior[rownames(widePrior) %in% colnames(featureMat),
                         colnames(widePrior) %in% colnames(metaMat)]
  return(widePrior)

}
